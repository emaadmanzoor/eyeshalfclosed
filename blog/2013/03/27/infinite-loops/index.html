<!DOCTYPE html>
<html>
<head>
<title>Infinite Loops</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type">
<meta content="Differences in Scala and Clojure." name="description">
<meta content="width=320" name="viewport">
<link href="http://eyeshalfclosed.com/blog/assets/css/reset.css" rel="stylesheet" type="text/css">
<link href="http://eyeshalfclosed.com/blog/assets/css/sunburst.css" media="screen" rel="stylesheet" type="text/css">
<link href="http://eyeshalfclosed.com/blog/assets/css/style.css" media="screen" rel="stylesheet" type="text/css">
<script src="http://eyeshalfclosed.com/blog/assets/js/jquery.js" type="text/javascript"></script><script src="http://eyeshalfclosed.com/blog/assets/js/jquery-tapir-min.js" type="text/javascript"></script><link href="http://eyeshalfclosed.com/blog/favicon.ico" rel="icon" type="image/x-icon">
<link href="http://eyeshalfclosed.com/blog/favicon.ico" rel="shortcut icon" type="image/x-icon">
</head>
<body>
    <div id="main">
      <div id="header">
        <div id="nav">
          <ul>
<li>
              <a href="http://eyeshalfclosed.com/">home</a>
            </li>
            <li>
              ·
            </li>
            <li>
              <a href="../../../../">
                index
              </a>
            </li>
            <li>
              ·
            </li>
            <li>
              <a href="http://feeds.feedburner.com/eyeshalfclosed">feed</a>
            </li>
          </ul>
</div>
      </div>
      <div class="article">
  <h1 class="article_title">
    Infinite Loops
  </h1>
  <div class="meta">
    <ul>
<li>
        On
        Mar 27, 2013
      </li>
      <li>
        By
        <a href="http://github.com/emaadmanzoor">
          Emaad Ahmed Manzoor
        </a>
      </li>
    </ul>
</div>
  <div class="body">
    <p>I draw to the end of my first week of Coursera's <a href="https://class.coursera.org/progfun-2012-001/">Scala course</a>. I have
taken it up as a solitary student with a vengeance, armed with a new year's
boost in morale since abandoning it midway last year. Expecting to blaze through
the first few weeks, I had planned to work through the course using both Scala
and Clojure and then churn out code walkthroughs of the <a href="https://github.com/nathanmarz/storm/">Storm</a> stream processing
platform (a Clojure project) and the <a href="http://kafka.apache.org/">Kafka</a> message queue (a Scala project).</p>

<p>It turns out there are some important differences in the way these two functional
languages work that are not skin-deep. This post documents the differences I found
and investigated while writing infinite-recursive methods in Scala and Clojure.</p>

<h2>The Background: Function Evaluation</h2>

<p>This week was about some basic concepts and theory on the substitution model of
function execution. In a nutshell, there are two ways a called function can
be reduced to a value in the substitution model:</p>

<ul>
<li> <strong>Call-by-value:</strong> The function's arguments are fully reduced before the
  function is applied to them. This is the <em>default</em> method of substitution
  in both Clojure and Scala. An example series of reductions could be:</li>
</ul>
<pre class="sunburst">
  sumOfSquares(<span class="Constant">4</span>, <span class="Constant">3</span> <span class="Keyword">+</span> <span class="Constant">2</span>)
    <span class="Keyword">=</span><span class="Keyword">&gt;</span> sumOfSquares(<span class="Constant">4</span>, <span class="Constant">5</span>) <span class="Comment"><span class="Comment">#</span> Argument reduced to a value</span>
      <span class="Keyword">=</span><span class="Keyword">&gt;</span> square(<span class="Constant">4</span>) <span class="Keyword">+</span> square(<span class="Constant">5</span>) <span class="Comment"><span class="Comment">#</span> Function applied</span>
        <span class="Keyword">=</span><span class="Keyword">&gt;</span> <span class="Constant">16</span> <span class="Keyword">+</span> <span class="Constant">25</span>
          <span class="Keyword">=</span><span class="Keyword">&gt;</span> <span class="Constant">41</span></pre>


<ul>
<li> <strong>Call-by-name:</strong> Applies the function to unreduced arguments. The arguments
  are evaluated in the body of the function <em>if needed</em>. This gives us a
  convenient way to short-circuit reduction of a parameter if it is unused in
  the function body. An example series of reductions for this would be:</li>
</ul>
<pre class="sunburst">
  sumOfSquares(<span class="Constant">4</span>, <span class="Constant">3</span> <span class="Keyword">+</span> <span class="Constant">2</span>)
    <span class="Keyword">=</span><span class="Keyword">&gt;</span> square(<span class="Constant">4</span>) <span class="Keyword">+</span> square(<span class="Constant">3</span> <span class="Keyword">+</span> <span class="Constant">2</span>) <span class="Comment"><span class="Comment">#</span> Function applied</span>
      <span class="Keyword">=</span><span class="Keyword">&gt;</span> square(<span class="Constant">4</span>) <span class="Keyword">+</span> square(<span class="Constant">5</span>) <span class="Comment"><span class="Comment">#</span> Argument reduced</span>
        <span class="Keyword">=</span><span class="Keyword">&gt;</span> <span class="Constant">16</span> <span class="Keyword">+</span> <span class="Constant">25</span>
          <span class="Keyword">=</span><span class="Keyword">&gt;</span> <span class="Constant">41</span></pre>


<p>Note that I have omitted some of the reduction steps for brevity.</p>

<h2>The Task: Infinite Recursion</h2>

<p>An in-class exercise was to write a function for the boolean-and of two variables without
using the built-in primitives. The crux of this task was to remember the short-circuits:</p>

<pre class="sunburst">
  true <span class="Keyword">&amp;</span><span class="Keyword">&amp;</span> Y <span class="Keyword">==</span> Y
  false <span class="Keyword">&amp;</span><span class="Keyword">&amp;</span> Y <span class="Keyword">==</span> false</pre>


<p>In Scala, this can be quickly accomplished by:</p>

<pre class="sunburst">
  <span class="Storage">def</span> <span class="Entity">and2</span>(x: <span class="Variable">Boolean</span>, y: <span class="Variable">Boolean</span>) = if (<span class="Variable">x</span>) y else <span class="Variable">false</span> </pre>


<p>But the method above can be broken, and our weapon of choice is the infinite recursion loop:</p>

<pre class="sunburst">
  <span class="Storage">def</span> <span class="Entity">loop</span>: <span class="Entity">Boolean</span> = <span class="Entity">loop</span></pre>


<p>This defines a function that calls itself. Note that because this is a <em>def</em> and not
a <em>val</em>, the right-hand-side of the assignment is evaluated only when the function is
called. <em>val</em>, in contrast, evaluates the right-hand-side at definition time.</p>

<p>Now if we provide this function as an argument to our and-function, we see the following
reduction happening (remember that Scala reduces by-value):</p>

<pre class="sunburst">
  and2(false, loop)
    <span class="Keyword">=</span><span class="Keyword">&gt;</span> <span class="Comment"><span class="Comment">#</span> Hangs when trying to evaluate the "loop" method</span></pre>


<p>What we would expect is a short-circuit as soon as we see a false first argument. To
achieve this, we can coax Scala into reducing a particular argument by-name instead:</p>

<pre class="sunburst">
  <span class="Storage">def</span> <span class="Entity">and2</span>(x: <span class="Variable">Boolean</span>, y:=&gt; <span class="Variable">Boolean</span>) = if (<span class="Variable">x</span>) y else <span class="Variable">false</span></pre>


<p>The reduction for this would then be:</p>

<pre class="sunburst">
  and2(false, loop)
    <span class="Keyword">=</span><span class="Keyword">&gt;</span> <span class="Keyword">if</span> (false) loop <span class="Keyword">else</span> false
       <span class="Keyword">=</span><span class="Keyword">&gt;</span> false</pre>


<p>The infinite <em>loop</em> is never evaluated, since we have forced Scala to evaluate the
second parameter by-name instead of by-value. Hence, we achieve our desired behaviour.</p>

<h2>The Divide I: Infinite Loops</h2>

<p>Translating this functionality to Clojure seemed trivial until I slammed into some
odd behaviour. To start with, let's write an innocent infinite loop function:</p>

<pre class="sunburst">
  (defn myLoop [] (myLoop))</pre>


<p>And let's run this method and watch it eat up our CPU:</p>

<pre class="sunburst">
  user<span class="Keyword">=</span><span class="Keyword">&gt;</span> (myLoop)
  StackOverflowError  user<span class="Keyword">/</span>myLoop (NO_SOURCE_FILE:<span class="Constant">1</span>)</pre>


<p>Unexpected, right? I was stumped! After a while being a headless chicken
burrowing into the details of function argument reduction in Clojure, I
stumbled onto <a href="http://paulbarry.com/articles/2009/09/02/infinite-recursion">this illuminating blog post</a>, comparing infinite loops
in a number of languages. The sneaky culprit turned out to be
<em>tail-call optimization</em>.</p>

<h3>Tail-Call Optimization</h3>

<p>Let's see what this means by a simple reduction example, applied to calculating
the sum of ones upto <em>N</em>. Here is the non-tail-call-optimized reduction:</p>

<pre class="sunburst">
  sumToN(<span class="Constant">5</span>)
    <span class="Keyword">=</span><span class="Keyword">&gt;</span> <span class="Constant">1</span> <span class="Keyword">+</span> sumToN(<span class="Constant">4</span>)
    <span class="Keyword">=</span><span class="Keyword">&gt;</span> <span class="Constant">1</span> <span class="Keyword">+</span> <span class="Constant">1</span> <span class="Keyword">+</span> sumToN(<span class="Constant">3</span>)
    <span class="Keyword">=</span><span class="Keyword">&gt;</span> <span class="Constant">1</span> <span class="Keyword">+</span> <span class="Constant">1</span> <span class="Keyword">+</span> <span class="Constant">1</span> <span class="Keyword">+</span> sumToN(<span class="Constant">2</span>)
    <span class="Keyword">=</span><span class="Keyword">&gt;</span> <span class="Constant">1</span> <span class="Keyword">+</span> <span class="Constant">1</span> <span class="Keyword">+</span> <span class="Constant">1</span> <span class="Keyword">+</span> <span class="Constant">1</span> <span class="Keyword">+</span> sumToN(<span class="Constant">1</span>)
    <span class="Keyword">=</span><span class="Keyword">&gt;</span> <span class="Constant">1</span> <span class="Keyword">+</span> <span class="Constant">1</span> <span class="Keyword">+</span> <span class="Constant">1</span> <span class="Keyword">+</span> <span class="Constant">1</span> <span class="Keyword">+</span> <span class="Constant">1</span> <span class="Comment"><span class="Comment">#</span> sumToN(1) returns</span>
    <span class="Keyword">=</span><span class="Keyword">&gt;</span> <span class="Constant">1</span> <span class="Keyword">+</span> <span class="Constant">1</span> <span class="Keyword">+</span> <span class="Constant">1</span> <span class="Keyword">+</span> <span class="Constant">2</span>     <span class="Comment"><span class="Comment">#</span> sumToN(2) returns</span>
    <span class="Keyword">=</span><span class="Keyword">&gt;</span> <span class="Constant">1</span> <span class="Keyword">+</span> <span class="Constant">1</span> <span class="Keyword">+</span> <span class="Constant">3</span>         <span class="Comment"><span class="Comment">#</span> sumToN(3) returns</span>
    <span class="Keyword">=</span><span class="Keyword">&gt;</span> <span class="Constant">1</span> <span class="Keyword">+</span> <span class="Constant">4</span>             <span class="Comment"><span class="Comment">#</span> sumToN(4) returns</span>
    <span class="Keyword">=</span><span class="Keyword">&gt;</span> <span class="Constant">5</span>                 <span class="Comment"><span class="Comment">#</span> sumToN(5) returns </span></pre>


<p>Observe how the chain of execution gets wider with increasing <em>N</em>. Each function call,
is appended to the call stack. Once the last function has been reduced, only then is
the stack collapsed by subsequently reducing each function. The function <em>sumToN</em>
has a <em>tail call</em>.</p>

<p>Our <em>sumToN</em> function can be optimized by simply
adding an additional accumulator parameter. This parameter, along with the current
<em>N</em> value, maintains the <em>state</em> of the function evaluation at that instant.</p>

<pre class="sunburst">
  sumToN(<span class="Constant">0</span>, <span class="Constant">5</span>)
    <span class="Keyword">=</span><span class="Keyword">&gt;</span> sumToN(<span class="Constant">1</span>, <span class="Constant">4</span>)
    <span class="Keyword">=</span><span class="Keyword">&gt;</span> sumToN(<span class="Constant">2</span>, <span class="Constant">3</span>)
    <span class="Keyword">=</span><span class="Keyword">&gt;</span> sumToN(<span class="Constant">3</span>, <span class="Constant">2</span>)
    <span class="Keyword">=</span><span class="Keyword">&gt;</span> sumToN(<span class="Constant">4</span>, <span class="Constant">1</span>)
    <span class="Keyword">=</span><span class="Keyword">&gt;</span> sumToN(<span class="Constant">5</span>, <span class="Constant">0</span>)
    <span class="Keyword">=</span><span class="Keyword">&gt;</span> <span class="Constant">5</span></pre>


<p>Notice how the evaluation of this function always has a constant tail length, and hence
accumulates a constant amount of space on the call stack for any <em>N</em> value.</p>

<h3>Scala Does Tail-Call Optimization By Default</h3>

<p>And this happens automatically. This is why the Scala infinite loop function we wrote
earlier actually executed infinitely. In contrast, Clojure does not, and the infinite
function additions to the call stack eventually triggers a stack overflow.</p>

<h2>The Divide II: Lazy Evaluation</h2>

<p>To mimic Scala's behaviour, let's enforce tail-call optimization in Clojure:</p>

<pre class="sunburst">
  (defn myLoop [] ((<span class="Keyword">loop</span> [] () (recur))))</pre>


<p>Now let's write an <em>and</em> method and try the same exercise we did in Scala:</p>

<pre class="sunburst">
  user=&gt; (defn and2 [x y] (<span class="Keyword">if</span> (= x true) y false))
  <span class="Constant"><span class="Constant">#</span>'user/and2</span>
  user=&gt; (and2 false myLoop) <span class="Comment"><span class="Comment">;</span> Should short-circuit</span>
  false
  user=&gt; (and2 true myLoop)  <span class="Comment"><span class="Comment">;</span> Should hang</span>
  <span class="Constant"><span class="Constant">#</span>&lt;user</span>$myLoop user$myLoop@4d91f801&gt;</pre>


<p>This was unexpected. Where is our infinite loop?</p>

<p>The culprit this time turns out to be <em>lazy evaluation</em>; a function is not
evaluated to its value unless explicitly required. Clojure uses lazy evaluation
by default, so instead of evaluating the function, it simply returns it to
us, should we choose to explictly evaluate it later. In contrast, Scala
begins evaluating the <em>loop</em> function within the if-condition and hence
runs into an infinite loop.</p>

<h2>Bonus Excercise: Lazy Evaluation In Haskell</h2>

<p>I don't know Haskell at all, but <a href="http://paulbarry.com/articles/2009/09/02/infinite-recursion">this blog post</a> pointed out an important
difference between lazy evaluation in Haskell and Clojure. Consider this
Haskell infinitely-recursive function:</p>

<pre class="sunburst">
  forever = forever</pre>


<p>When you call this function, it blocks infinitely, as expected. But in contrast
to Clojure and Scala's infinite loops, this one uses no CPU! Why?</p>

<p>I'll quote the explanation provided in the comments to the original blog post here:</p>

<blockquote><p>Haskell has lazy evaluation and call-by-need semantics. Since you aren't doing anything with your forever function, it will never get evaluated. You have to enforce strict evaluation, by e.g. printing it out. (The same mistake is done on the Computer Language Benchmark Game. There's an Array sorting benchmark where Haskell just blows away even hand-optimized C. The secret is that the benchmark never prints out the contents of the sorted array. The C compiler isn't smart enough to recognize that the array is never actually used anywhere, but Haskell is, and so the entire benchmark basically compiles down to the equivalent of "int main() { return 0; }".)
<cite><a href="http://paulbarry.com/articles/2009/09/02/infinite-recursion#comment-5326">Jörg W Mittag</a></cite></p></blockquote>
  </div>
</div>
      <div id="other-articles">
        <div class="older">
          <ul>
<li>
              <h3>
                <a href="../../../../2012/03/17/throwing-darts/" title="Estimating π on a beanstalkd cluster.">
                  « Throwing Darts
                </a>
              </h3>
            </li>
          </ul>
</div>
        <div class="newer">
          <ul></ul>
</div>
      </div>
      <div class="clear"></div>
      <div class="comments">
        <div id="disqus_thread"></div>
        <script src="http://disqus.com/forums/eyeshalfclosed/embed.js" type="text/javascript"></script><noscript>
          <a href="http://disqus.com/forums/eyeshalfclosed/?url=ref">
            View the discussion thread
          </a>
        </noscript>
      </div>
      <!-- / disqus adds too much visual crap -->
      <style type="text/css">
        .dsq-dc-logo {
          display: none !important; }
      </style>
<div id="page-footer">
        Crafted with
        <a href="http://nanoc.stoneship.org/">
          nanoc
        </a>
         
        ·
         
        Source on
        <a href="http://github.com/emaadmanzoor/eyeshalfclosed/">
          Github
        </a>
        <br>
</div>
    </div>
    <script>
      //<![CDATA[
        var _gaq = _gaq || [];
        _gaq.push(['_setAccount', 'UA-36072775-1']);
        _gaq.push(['_trackPageview']);
        
        (function() {
          var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
          ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
          var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
        })();
      //]]>
    </script>
</body>
</html>
