<!DOCTYPE html>
<html>
<head>
<title>Infinite Loops</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type">
<meta content="Embodiments in Scala, Clojure and Haskell." name="description">
<meta content="width=320" name="viewport">
<link href="http://eyeshalfclosed.com/blog/assets/css/reset.css" rel="stylesheet" type="text/css">
<link href="http://eyeshalfclosed.com/blog/assets/css/sunburst.css" media="screen" rel="stylesheet" type="text/css">
<link href="http://eyeshalfclosed.com/blog/assets/css/style.css" media="screen" rel="stylesheet" type="text/css">
<script src="http://eyeshalfclosed.com/blog/assets/js/jquery.js" type="text/javascript"></script><script src="http://eyeshalfclosed.com/blog/assets/js/jquery-tapir-min.js" type="text/javascript"></script><link href="http://eyeshalfclosed.com/blog/favicon.ico" rel="icon" type="image/x-icon">
<link href="http://eyeshalfclosed.com/blog/favicon.ico" rel="shortcut icon" type="image/x-icon">
</head>
<body>
    <div id="main">
      <div id="header">
        <div id="nav">
          <ul>
<li>
              <a href="http://eyeshalfclosed.com/">home</a>
            </li>
            <li>
              ·
            </li>
            <li>
              <a href="../../../../">
                index
              </a>
            </li>
            <li>
              ·
            </li>
            <li>
              <a href="http://feeds.feedburner.com/eyeshalfclosed">feed</a>
            </li>
          </ul>
</div>
      </div>
      <div class="article">
  <h1 class="article_title">
    Infinite Loops
  </h1>
  <div class="meta">
    <ul>
<li>
        On
        Mar 27, 2013
      </li>
      <li>
        By
        <a href="http://github.com/emaadmanzoor">
          Emaad Ahmed Manzoor
        </a>
      </li>
    </ul>
</div>
  <div class="body">
    <p>My second attempt at Coursera's <a href="https://class.coursera.org/progfun-2012-001/">Scala course</a> turned out to have a
refreshingly twisty plot. The grand plan this time is to blaze through the
course using both Scala and Clojure, and then top it off by dishing out
code reviews of <a href="https://github.com/nathanmarz/storm/">Storm</a> (Clojure) and <a href="http://kafka.apache.org/">Kafka</a> (Scala).</p>

<p>I didn't expect the first week to hit me with a bunch of creepy differences
in details that aren't skin-deep. How hard could it be to write an infinite
loop, right?</p>

<h2>The Background: Function Evaluation</h2>

<p>The week started with some basic concepts on the substitution model of
function execution. In a nutshell, there are two ways a called function can
be reduced to a value in the substitution model:</p>

<ul>
<li> <strong>Call-by-value:</strong> The function's arguments are fully reduced before the
  function is applied to them. This is the <em>default</em> method of substitution
  in both Clojure and Scala. An example series of reductions could be:</li>
</ul>
<pre class="sunburst">
  sumOfSquares(<span class="Constant">4</span>, <span class="Constant">3</span> <span class="Keyword">+</span> <span class="Constant">2</span>)
    <span class="Keyword">=</span><span class="Keyword">&gt;</span> sumOfSquares(<span class="Constant">4</span>, <span class="Constant">5</span>) <span class="Comment"><span class="Comment">#</span> Argument reduced to a value</span>
      <span class="Keyword">=</span><span class="Keyword">&gt;</span> square(<span class="Constant">4</span>) <span class="Keyword">+</span> square(<span class="Constant">5</span>) <span class="Comment"><span class="Comment">#</span> Function applied</span>
        <span class="Keyword">=</span><span class="Keyword">&gt;</span> <span class="Constant">16</span> <span class="Keyword">+</span> <span class="Constant">25</span>
          <span class="Keyword">=</span><span class="Keyword">&gt;</span> <span class="Constant">41</span></pre>


<ul>
<li> <strong>Call-by-name:</strong> Applies the function to unreduced arguments. The arguments
  are evaluated in the body of the function <em>if needed</em>. This gives us a
  convenient way to short-circuit evaluation of a parameter if it is unused in
  the function body. An example series of reductions for this would be:</li>
</ul>
<pre class="sunburst">
  sumOfSquares(<span class="Constant">4</span>, <span class="Constant">3</span> <span class="Keyword">+</span> <span class="Constant">2</span>)
    <span class="Keyword">=</span><span class="Keyword">&gt;</span> square(<span class="Constant">4</span>) <span class="Keyword">+</span> square(<span class="Constant">3</span> <span class="Keyword">+</span> <span class="Constant">2</span>) <span class="Comment"><span class="Comment">#</span> Function applied</span>
      <span class="Keyword">=</span><span class="Keyword">&gt;</span> square(<span class="Constant">4</span>) <span class="Keyword">+</span> square(<span class="Constant">5</span>) <span class="Comment"><span class="Comment">#</span> Argument reduced</span>
        <span class="Keyword">=</span><span class="Keyword">&gt;</span> <span class="Constant">16</span> <span class="Keyword">+</span> <span class="Constant">25</span>
          <span class="Keyword">=</span><span class="Keyword">&gt;</span> <span class="Constant">41</span></pre>


<p>Note that I have omitted some of the reduction steps for brevity.</p>

<h2>The Plan: Infinite Recursion</h2>

<p>An in-class exercise was to write a function performing the boolean-and of two variables
without using the built-in primitives. The crux was about remembering the short-circuits:</p>

<pre class="sunburst">
  true <span class="Keyword">&amp;</span><span class="Keyword">&amp;</span> Y <span class="Keyword">==</span> Y
  false <span class="Keyword">&amp;</span><span class="Keyword">&amp;</span> Y <span class="Keyword">==</span> false</pre>


<p>In Scala, this can be quickly accomplished by:</p>

<pre class="sunburst">
  <span class="Storage">def</span> <span class="Entity">and2</span>(x: <span class="Variable">Boolean</span>, y: <span class="Variable">Boolean</span>) = if (<span class="Variable">x</span>) y else <span class="Variable">false</span> </pre>


<p>But the method above can be broken, and our weapon of choice is the infinite recursion loop:</p>

<pre class="sunburst">
  <span class="Storage">def</span> <span class="Entity">loop</span>: <span class="Entity">Boolean</span> = <span class="Entity">loop</span></pre>


<p>This defines a function that calls itself. Note that because this is a <em>def</em> and not
a <em>val</em>, the right-hand-side of the assignment is evaluated only when the function is
called. <em>val</em>, in contrast, evaluates the right-hand-side at definition time.</p>

<p>Now if we provide this function as an argument to our boolean-and'er, we see the following
reduction happening (remember that Scala reduces by-value):</p>

<pre class="sunburst">
  and2(false, loop)
    <span class="Keyword">=</span><span class="Keyword">&gt;</span> <span class="Comment"><span class="Comment">#</span> Hangs when trying to evaluate the "loop" method</span></pre>


<p>What we'd like is to not evaluate the second parameter at all if the first is false.
To achieve this, we can coax Scala into reducing a particular argument by-name instead:</p>

<pre class="sunburst">
  <span class="Storage">def</span> <span class="Entity">and2</span>(x: <span class="Variable">Boolean</span>, y:=&gt; <span class="Variable">Boolean</span>) = if (<span class="Variable">x</span>) y else <span class="Variable">false</span></pre>


<p>The reduction for this would then be:</p>

<pre class="sunburst">
  and2(false, loop)
    <span class="Keyword">=</span><span class="Keyword">&gt;</span> <span class="Keyword">if</span> (false) loop <span class="Keyword">else</span> false
       <span class="Keyword">=</span><span class="Keyword">&gt;</span> false</pre>


<p>The infinite <em>loop</em> is never evaluated, since we have forced Scala to evaluate the
second parameter by-name instead of by-value. Hence, we achieve our desired behaviour.</p>

<h2>The Twist I: TCO</h2>

<p>Translating this functionality to Clojure seemed trivial until I slammed into some
odd behaviour. To start with, let's write an innocent infinite loop function:</p>

<pre class="sunburst">
  (defn myLoop [] (myLoop))</pre>


<p>And let's run this method and watch it eat up our CPU:</p>

<pre class="sunburst">
  user<span class="Keyword">=</span><span class="Keyword">&gt;</span> (myLoop)
  StackOverflowError  user<span class="Keyword">/</span>myLoop (NO_SOURCE_FILE:<span class="Constant">1</span>)</pre>


<p>Unexpected, right? I was stumped! After some headless-chicken-scrambling
into the details of function argument reduction in Clojure, I
stumbled onto <a href="http://paulbarry.com/articles/2009/09/02/infinite-recursion">this illuminating blog post</a>, comparing infinite loops
in a number of languages. The sneaky culprit turned out to be
TCO, or <em>tail-call optimization</em>.</p>

<h3>Tail-Call Optimization</h3>

<p>Let's look at what this means by a simple reduction example, applied to calculating
the sum of ones upto <em>N</em>. Here is the non-tail-call-optimized reduction:</p>

<pre class="sunburst">
  sumToN(<span class="Constant">5</span>)
    <span class="Keyword">=</span><span class="Keyword">&gt;</span> <span class="Constant">1</span> <span class="Keyword">+</span> sumToN(<span class="Constant">4</span>)
    <span class="Keyword">=</span><span class="Keyword">&gt;</span> <span class="Constant">1</span> <span class="Keyword">+</span> <span class="Constant">1</span> <span class="Keyword">+</span> sumToN(<span class="Constant">3</span>)
    <span class="Keyword">=</span><span class="Keyword">&gt;</span> <span class="Constant">1</span> <span class="Keyword">+</span> <span class="Constant">1</span> <span class="Keyword">+</span> <span class="Constant">1</span> <span class="Keyword">+</span> sumToN(<span class="Constant">2</span>)
    <span class="Keyword">=</span><span class="Keyword">&gt;</span> <span class="Constant">1</span> <span class="Keyword">+</span> <span class="Constant">1</span> <span class="Keyword">+</span> <span class="Constant">1</span> <span class="Keyword">+</span> <span class="Constant">1</span> <span class="Keyword">+</span> sumToN(<span class="Constant">1</span>)
    <span class="Keyword">=</span><span class="Keyword">&gt;</span> <span class="Constant">1</span> <span class="Keyword">+</span> <span class="Constant">1</span> <span class="Keyword">+</span> <span class="Constant">1</span> <span class="Keyword">+</span> <span class="Constant">1</span> <span class="Keyword">+</span> <span class="Constant">1</span> <span class="Comment"><span class="Comment">#</span> sumToN(1) returns</span>
    <span class="Keyword">=</span><span class="Keyword">&gt;</span> <span class="Constant">1</span> <span class="Keyword">+</span> <span class="Constant">1</span> <span class="Keyword">+</span> <span class="Constant">1</span> <span class="Keyword">+</span> <span class="Constant">2</span>     <span class="Comment"><span class="Comment">#</span> sumToN(2) returns</span>
    <span class="Keyword">=</span><span class="Keyword">&gt;</span> <span class="Constant">1</span> <span class="Keyword">+</span> <span class="Constant">1</span> <span class="Keyword">+</span> <span class="Constant">3</span>         <span class="Comment"><span class="Comment">#</span> sumToN(3) returns</span>
    <span class="Keyword">=</span><span class="Keyword">&gt;</span> <span class="Constant">1</span> <span class="Keyword">+</span> <span class="Constant">4</span>             <span class="Comment"><span class="Comment">#</span> sumToN(4) returns</span>
    <span class="Keyword">=</span><span class="Keyword">&gt;</span> <span class="Constant">5</span>                 <span class="Comment"><span class="Comment">#</span> sumToN(5) returns </span></pre>


<p>Observe how the chain of execution gets wider with increasing <em>N</em>. Each function call
is appended to the call stack. Only when the last function is reduced does
the stack get collapsed by subsequently reducing each function.</p>

<p>Our <em>sumToN</em> function can be tail-call-optimized by simply adding an additional
laccumulator parameter. This parameter, along with the current <em>N</em> value, maintains
the <em>state</em> of the function evaluation at that instant.</p>

<pre class="sunburst">
  sumToN(<span class="Constant">0</span>, <span class="Constant">5</span>)
    <span class="Keyword">=</span><span class="Keyword">&gt;</span> sumToN(<span class="Constant">1</span>, <span class="Constant">4</span>)
    <span class="Keyword">=</span><span class="Keyword">&gt;</span> sumToN(<span class="Constant">2</span>, <span class="Constant">3</span>)
    <span class="Keyword">=</span><span class="Keyword">&gt;</span> sumToN(<span class="Constant">3</span>, <span class="Constant">2</span>)
    <span class="Keyword">=</span><span class="Keyword">&gt;</span> sumToN(<span class="Constant">4</span>, <span class="Constant">1</span>)
    <span class="Keyword">=</span><span class="Keyword">&gt;</span> sumToN(<span class="Constant">5</span>, <span class="Constant">0</span>)
    <span class="Keyword">=</span><span class="Keyword">&gt;</span> <span class="Constant">5</span></pre>


<p>Notice how the evaluation of this function always has a constant tail length, and hence
accumulates a constant amount of space on the call stack for any <em>N</em> value.</p>

<h3>Scala Does Tail-Call Optimization By Default</h3>

<p>And this happens really quietly. This is why the Scala infinite loop function we wrote
earlier actually executed infinitely. In contrast, the Clojure one never runs, and the
infinite function additions to the call stack eventually trigger a stack overflow.</p>

<h2>The Twist II: Lazy Evaluation</h2>

<p>To mimic Scala's behaviour, let's enforce tail-call optimization in Clojure:</p>

<pre class="sunburst">
  (defn myLoop [] ((<span class="Keyword">loop</span> [] () (recur))))</pre>


<p>Now let's try the same boolean-and'ing exercise we did in Scala:</p>

<pre class="sunburst">
  user=&gt; (defn and2 [x y] (<span class="Keyword">if</span> (= x true) y false))
  <span class="Constant"><span class="Constant">#</span>'user/and2</span>
  user=&gt; (and2 false myLoop) <span class="Comment"><span class="Comment">;</span> Should short-circuit</span>
  false
  user=&gt; (and2 true myLoop)  <span class="Comment"><span class="Comment">;</span> Should hang</span>
  <span class="Constant"><span class="Constant">#</span>&lt;user</span>$myLoop user$myLoop@4d91f801&gt;</pre>


<p>What did it just dump out on our feet? Where is our infinite loop?</p>

<p>The culprit this time turns out to be <em>lazy evaluation</em>; a function is not
evaluated to its return value unless explicitly asked to. Clojure uses lazy evaluation
by default, so instead of evaluating the function, it simply returns it to
us, should we choose to explicitly evaluate it later. In contrast, Scala
begins evaluating the <em>loop</em> function within the if-condition and hence
runs into an infinite loop. That weird dump is a representation of our Clojure function.</p>

<h2>Bonus Twist: Really Lazy Evaluation</h2>

<p>Another interesting fact a comment in <a href="http://paulbarry.com/articles/2009/09/02/infinite-recursion">this blog post</a> pointed out was an important
difference between lazy evaluation in Haskell and Clojure. Consider this
Haskell infinitely-recursive function:</p>

<pre class="sunburst">
  forever = forever</pre>


<p>When you call this function, it blocks infinitely, as expected. But in contrast
to Clojure and Scala's infinite loops, this one uses no CPU! Why?</p>

<p>It turns out Haskell is <em>extremely lazy</em>. Since our function doesn't really do anything,
it's never really executed. You could simply print something to the screen within the
function to set Haskell on fire, but it won't budge until you do so.</p>

<p>The <a href="http://benchmarksgame.alioth.debian.org/">Computer Language Benchmark Game</a> fell into Haskell's lazy trap once, when
the array sorting benchmark in Haskell outperformed hand-optimized C. It turned out that
the sorted array was never printed out. So the Haskell function took the lazy way out
and did absolutely nothing, while C worked hard to sort a bunch of numbers that would
never see the light of day.</p>

<p><em>Thanks to <a href="https://github.com/tribhuvanesh">@tribhuvanesh</a> and
<a href="https://github.com/racheesingh/">@rachee_singh</a> for reviewing
drafts of this.</em></p>
  </div>
</div>
      <div id="other-articles">
        <div class="older">
          <ul>
<li>
              <h3>
                <a href="../../../../2012/03/17/throwing-darts/" title="Estimating π on a beanstalkd cluster.">
                  « Throwing Darts
                </a>
              </h3>
            </li>
          </ul>
</div>
        <div class="newer">
          <ul></ul>
</div>
      </div>
      <div class="clear"></div>
      <div class="comments">
        <div id="disqus_thread"></div>
        <script src="http://disqus.com/forums/eyeshalfclosed/embed.js" type="text/javascript"></script><noscript>
          <a href="http://disqus.com/forums/eyeshalfclosed/?url=ref">
            View the discussion thread
          </a>
        </noscript>
      </div>
      <!-- / disqus adds too much visual crap -->
      <style type="text/css">
        .dsq-dc-logo {
          display: none !important; }
      </style>
<div id="page-footer">
        Crafted with
        <a href="http://nanoc.stoneship.org/">
          nanoc
        </a>
         
        ·
         
        Source on
        <a href="http://github.com/emaadmanzoor/eyeshalfclosed/">
          Github
        </a>
        <br>
</div>
    </div>
    <script>
      //<![CDATA[
        var _gaq = _gaq || [];
        _gaq.push(['_setAccount', 'UA-36072775-1']);
        _gaq.push(['_trackPageview']);
        
        (function() {
          var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
          ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
          var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
        })();
      //]]>
    </script>
</body>
</html>
